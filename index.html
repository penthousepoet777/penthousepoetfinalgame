<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>The Penthouse Poet — Neon Dreams (Jazz-Noir Gritty Preview)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<style>
  :root{--bg:#07070b;--accent:#c9b07a;--cool:#5fe0ff}
  html,body{height:100%;margin:0;background:var(--bg);color:#eaeef2;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  #wrap{position:relative;width:100vw;left:50%;margin-left:-50vw;height:100vh;overflow:hidden;touch-action:none}
  canvas{display:block;width:100%;height:100%}
  #overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:60;background:linear-gradient(180deg,rgba(0,0,0,0.85),rgba(0,0,0,0.98));text-align:center;padding:22px}
  #title{font-size:clamp(20px,5vw,42px);font-weight:800;color:var(--accent);margin-bottom:6px;text-shadow:0 6px 30px rgba(0,0,0,0.6)}
  .btn{padding:12px 22px;border-radius:999px;border:none;background:linear-gradient(90deg,var(--cool),var(--accent));color:#02121a;font-weight:700;cursor:pointer;font-size:16px}
  .hint{color:#cfe8ff;margin-top:12px;font-size:13px;opacity:0.95}
  #hud{position:fixed;left:12px;bottom:12px;z-index:70;padding:8px 12px;border-radius:10px;background:rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.03);font-size:13px}
  #quote{position:fixed;left:50%;bottom:6%;transform:translateX(-50%);z-index:75;padding:12px 16px;border-radius:10px;background:linear-gradient(180deg,rgba(0,0,0,0.94),rgba(0,0,0,0.78));display:none;color:#fff;max-width:86%;font-family:Georgia,serif}
  #joystick{position:fixed;left:12px;bottom:96px;width:110px;height:110px;border-radius:999px;border:1px solid rgba(255,255,255,0.04);display:none;z-index:70;background:rgba(255,255,255,0.02)}
  #knob{position:absolute;left:32px;top:32px;width:46px;height:46px;border-radius:999px;background:var(--cool)}
  #interact{position:fixed;right:12px;bottom:96px;z-index:70;display:none}
  .btnBig{padding:12px 14px;border-radius:999px;background:linear-gradient(90deg,var(--cool),var(--accent));border:none;color:#02121a;font-weight:700;cursor:pointer}
  .grain{pointer-events:none;position:fixed;inset:0;opacity:0.06;z-index:9999;background-image:url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22256%22 height=%22256%22><filter id=%22n%22><feTurbulence baseFrequency=%220.9%22 numOctaves=%221%22 stitchTiles=%22stitch%22/><feColorMatrix type=%22saturate%22 values=%220%22/></filter><rect width=%22100%25%22 height=%22100%25%22 filter=%22url(%23n)%22 opacity=%22.6%22 /></svg>');mix-blend-mode:overlay}
  @media (hover:none) and (pointer:coarse){ #joystick{display:block} #interact{display:block} }
  iframe, canvas, button { pointer-events:auto !important; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas" aria-label="Neon Jazz Gritty canvas"></canvas>

  <div id="overlay" role="dialog" aria-modal="true">
    <div id="title">THE PENTHOUSE POET</div>
    <div style="color:#cfe8ff;margin-bottom:14px">Neon Dreams — Jazz-Noir (Gritty Preview)</div>
    <button id="startBtn" class="btn">ENTER NEON NIGHT</button>
    <div class="hint">Tap to start • 8s cinematic → gameplay • Joystick on mobile</div>
  </div>

  <div id="hud">Mode: Idle · Fragments: 0</div>
  <div id="quote"></div>
  <div id="joystick"><div id="knob"></div></div>
  <div id="interact"><button id="interactBtn" class="btnBig">Interact</button></div>
  <div class="grain"></div>
</div>

<!-- Audio layers: jazz loop (Pixabay), rain ambience, soft footstep -->
<audio id="jazz" loop preload="auto">
  <source src="https://cdn.pixabay.com/download/audio/2021/08/09/audio_6e8a3a0e1c.mp3?filename=sad-jazz-loop-11095.mp3" type="audio/mpeg">
</audio>
<audio id="rain" loop preload="auto">
  <source src="https://cdn.pixabay.com/download/audio/2021/10/05/audio_45b3b8b1f6.mp3?filename=light-rain-ambient-111351.mp3" type="audio/mpeg">
</audio>
<audio id="foot" preload="auto">
  <source src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_2e6a2a3f92.mp3?filename=footstep-soft-7333.mp3" type="audio/mpeg">
</audio>

<!-- three.js and postprocessing UMD -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/shaders/FXAAShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/PointerLockControls.js"></script>

<script>
// Neon Jazz Gritty — base world with cinematic cutscene
(() => {
  const startBtn = document.getElementById('startBtn');
  const overlay = document.getElementById('overlay');
  const canvas = document.getElementById('canvas');
  const hud = document.getElementById('hud');
  const quote = document.getElementById('quote');
  const jazz = document.getElementById('jazz');
  const rain = document.getElementById('rain');
  const foot = document.getElementById('foot');
  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('knob');
  const interactBtn = document.getElementById('interactBtn');

  let renderer, scene, camera, composer, clock, raycaster;
  let controls, listener;
  let player = new THREE.Object3D();
  let move = {f:0,b:0,l:0,r:0};
  let npcs = [];
  let audioCtx = null, audioStarted = false;
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

  // Simple poetic lines (for later NPCs)
  const LINES = [
    "You pay with moments and the city stores them like coins.",
    "Neon writes your name on the wet pavement.",
    "Tonight the skyline eats the stars.",
    "We barter with secrets in subway cars."
  ];

  // presets
  const PRESETS = {
    Ultra:{dpr:1.5, windows:2000, traffic:28},
    High:{dpr:1.15, windows:1100, traffic:20},
    Medium:{dpr:1.0, windows:700, traffic:12},
    Low:{dpr:0.7, windows:300, traffic:6}
  };
  function choosePreset(){ return isMobile ? PRESETS.Medium : PRESETS.High; }

  // Click/touch start — must do synchronous user gesture to allow audio on iOS
  async function onStart(e){
    e && e.preventDefault && e.preventDefault();
    overlay.style.display = 'none';
    // init audio context and play layers
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioStarted = true;
      // connect HTML audio elements to audioCtx for future mixing if desired
      const jazzSrc = audioCtx.createMediaElementSource(jazz);
      const rainSrc = audioCtx.createMediaElementSource(rain);
      const jazzGain = audioCtx.createGain(); jazzGain.gain.value = 0.9;
      const rainGain = audioCtx.createGain(); rainGain.gain.value = 0.45;
      jazzSrc.connect(jazzGain); rainSrc.connect(rainGain);
      jazzGain.connect(audioCtx.destination); rainGain.connect(audioCtx.destination);
      // start playing
      await jazz.play().catch(()=>{});
      await rain.play().catch(()=>{});
    } catch(err){
      console.warn('AudioContext failed or blocked:', err);
      // fallback: try to play audio elements directly
      try { jazz.play().catch(()=>{}); rain.play().catch(()=>{}); } catch(e){}
    }

    // initialize 3D if not already
    if(!renderer) await init();
    // start cinematic then enter gameplay
    startCutscene();
  }

  startBtn.addEventListener('click', onStart, {passive:false});
  startBtn.addEventListener('touchstart', onStart, {passive:false});

  // init three scene
  async function init(){
    const preset = choosePreset();

    renderer = new THREE.WebGLRenderer({canvas, antialias:true, powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, preset.dpr));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x07050a, 0.0032);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.05, 5000);
    camera.position.set(0,10,80); // start high for cutscene

    // audio listener for future positional audio
    listener = new THREE.AudioListener();
    camera.add(listener);

    // lights: cinematic, gritty
    scene.add(new THREE.HemisphereLight(0x6e7f9a, 0x050409, 0.6));
    const key = new THREE.DirectionalLight(0xffe3c6, 0.55); key.position.set(40,80,10); scene.add(key);

    // ground
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000,4000), new THREE.MeshStandardMaterial({color:0x07070a, roughness:0.05, metalness:0.35}));
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // skyline, windows, lights, traffic
    buildSkyline();
    createWindows(preset.windows);
    createStreetLamps();
    createTraffic(preset.traffic);
    createWaterTowers(20);

    // player anchor
    player.position.set(0,0.5,6);
    scene.add(player);

    // postprocess
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));
    const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.4, 0.8);
    composer.addPass(bloom);
    const fxaa = new THREE.ShaderPass(THREE.FXAAShader);
    fxaa.material.uniforms['resolution'].value.set(1/window.innerWidth, 1/window.innerHeight);
    composer.addPass(fxaa);

    // controls (pointerlock for desktop)
    controls = new THREE.PointerLockControls(camera, renderer.domElement);

    // inputs + mobile joystick
    setupInput();

    raycaster = new THREE.Raycaster();
    clock = new THREE.Clock();

    animate();
  }

  // --- scene builders ---
  function buildSkyline(){
    const group = new THREE.Group();
    for(let cx=-12; cx<=12; cx++){
      const bias = 1 - Math.abs(cx)/14;
      for(let d=0; d<6; d++){
        const h = 8 + Math.random()*(48*bias);
        const w = 3 + Math.random()*2;
        const depth = -(d*14 + Math.random()*6);
        const geom = new THREE.BoxGeometry(w,h,3 + Math.random()*2);
        const hue = 20 + Math.random()*40; // warmer tones for gritty
        const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hue/360,0.06,0.08 + Math.random()*0.04), roughness:0.46, metalness:0.2 });
        const m = new THREE.Mesh(geom, mat);
        m.position.set(cx*6 + (Math.random()*0.6-0.3), h/2 - 0.5, depth);
        group.add(m);
        if(Math.random()>0.7){
          const sign = new THREE.Mesh(new THREE.PlaneGeometry(w*0.8, h*0.45), new THREE.MeshBasicMaterial({color:0xffd7a8, transparent:true, opacity:0.06, side:THREE.DoubleSide}));
          sign.position.set(m.position.x, m.position.y, m.position.z + (1.8 + Math.random()*0.6)); group.add(sign);
        }
      }
    }
    scene.add(group);
  }

  let windowInst=null;
  function createWindows(count=700){
    const plane = new THREE.PlaneGeometry(0.62,0.46);
    const mat = new THREE.MeshBasicMaterial({color:0xfff3d8});
    windowInst = new THREE.InstancedMesh(plane, mat, count);
    let i=0;
    for(let n=0;n<count;n++){
      const x = (Math.random()*320 - 160);
      const y = 1.8 + Math.random()*86;
      const z = - (Math.random()*1000);
      const m = new THREE.Matrix4().makeTranslation(x,y,z);
      windowInst.setMatrixAt(i++, m);
      if(i>=count) break;
    }
    scene.add(windowInst);
  }

  function createStreetLamps(){
    for(let z=-10; z>-600; z-=12){
      [-10,10].forEach(x=>{
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.07,3.8,10), new THREE.MeshStandardMaterial({color:0x222222, roughness:0.6}));
        pole.position.set(x,2.2,z); scene.add(pole);
        const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.24,10,10), new THREE.MeshStandardMaterial({emissive:0xffecd1, emissiveIntensity:1.0}));
        lamp.position.set(x,3.6,z); scene.add(lamp);
        const pl = new THREE.PointLight(0xffe6d0, 0.9, 12, 2);
        pl.position.set(x,3.4,z); scene.add(pl);
      });
    }
  }

  const trafficArr = [];
  function createTraffic(n=12){
    for(let i=0;i<n;i++){
      const pts = [];
      const base = -10 - i*18;
      for(let p=0;p<8;p++) pts.push(new THREE.Vector3((Math.random()*6-3), 0.12, base - p*12));
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({color:0xffd8a8, transparent:true, opacity:0.6});
      const line = new THREE.Line(geo, mat); scene.add(line);
      trafficArr.push({line, speed:0.06 + Math.random()*0.12});
    }
  }

  function createWaterTowers(n=12){
    for(let i=0;i<n;i++){
      const geo = new THREE.CylinderGeometry(0.6,0.6,1.6,12);
      const mat = new THREE.MeshStandardMaterial({color:0x34281b, roughness:0.6});
      const w = new THREE.Mesh(geo, mat);
      w.position.set((Math.random()*220-110), 6 + Math.random()*64, -(Math.random()*1200));
      scene.add(w);
    }
  }

  // input & controls
  let dragging=false, lastX=0, lastY=0;
  function setupInput(){
    window.addEventListener('resize', onResize);
    document.addEventListener('keydown', onKey);
    document.addEventListener('keyup', onKeyUp);
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    renderer.domElement.addEventListener('touchend', onTouchEnd, {passive:false});
    renderer.domElement.addEventListener('click', onClick);
    if(isMobile){ document.getElementById('joystick').style.display='block'; document.getElementById('interact').style.display='block'; setupMobileLook(); setupJoystick(); }
  }

  function onKey(e){
    const k = e.key.toLowerCase();
    if(k==='w') move.f=1;
    if(k==='s') move.b=1;
    if(k==='a') move.l=1;
    if(k==='d') move.r=1;
    if(e.code==='Space'){ const hit=centerRaycast(); if(hit) interactWith(hit.object); }
  }
  function onKeyUp(e){ const k = e.key.toLowerCase(); if(k==='w') move.f=0; if(k==='s') move.b=0; if(k==='a') move.l=0; if(k==='d') move.r=0; }

  function onMouseDown(e){ dragging=true; lastX=e.clientX; lastY=e.clientY; }
  function onMouseUp(e){ dragging=false; }
  function onMouseMove(e){
    if(!dragging) return;
    const dx = (e.clientX - lastX) * 0.0022;
    const dy = (e.clientY - lastY) * 0.0022;
    player.rotation.y -= dx;
    camera.rotation.x = Math.max(-1.4, Math.min(1.4, camera.rotation.x - dy));
    lastX = e.clientX; lastY = e.clientY;
  }
  function onTouchEnd(e){ if(isMobile){ const hit=centerRaycast(); if(hit) interactWith(hit.object); } }
  function onClick(e){ if(isMobile) return; const rect = renderer.domElement.getBoundingClientRect(); const nx = ((e.clientX-rect.left)/rect.width)*2 -1; const ny = -((e.clientY-rect.top)/rect.height)*2 +1; raycaster.setFromCamera(new THREE.Vector2(nx,ny), camera); const hit = raycaster.intersectObjects(npcs, true)[0]; if(hit) interactWith(hit.object); }

  // mobile look
  function setupMobileLook(){
    let tracking=false, last=null;
    renderer.domElement.addEventListener('touchstart', (ev)=>{ if(ev.touches.length===1 && ev.touches[0].clientX > window.innerWidth/2){ tracking=true; last={x:ev.touches[0].clientX, y:ev.touches[0].clientY}; } }, {passive:false});
    renderer.domElement.addEventListener('touchmove', (ev)=>{ if(tracking){ const t = ev.touches[0]; const dx = (t.clientX-last.x)/window.innerWidth; const dy = (t.clientY-last.y)/window.innerHeight; player.rotation.y -= dx * Math.PI; camera.rotation.x = Math.max(-1.4, Math.min(1.4, camera.rotation.x - dy * Math.PI)); last = {x:t.clientX, y:t.clientY}; } }, {passive:false});
    renderer.domElement.addEventListener('touchend', ()=>{ tracking=false; }, {passive:false});
  }

  // joystick
  function setupJoystick(){
    let dragging=false, start=null, max=40;
    knob.style.transform='translate(0px,0px)';
    document.getElementById('joystick').addEventListener('touchstart',(e)=>{ e.preventDefault(); dragging=true; const t=e.touches[0]; start={x:t.clientX,y:t.clientY}; },{passive:false});
    document.getElementById('joystick').addEventListener('touchmove',(e)=>{ e.preventDefault(); if(!dragging) return; const t=e.touches[0]; const dx=t.clientX-start.x; const dy=t.clientY-start.y; const nx=Math.max(-max,Math.min(max,dx)); const ny=Math.max(-max,Math.min(max,dy)); knob.style.transform=`translate(${nx}px,${ny}px)`; move.f=(ny<-8)?1:0; move.b=(ny>8)?1:0; move.l=(nx<-8)?1:0; move.r=(nx>8)?1:0; },{passive:false});
    document.getElementById('joystick').addEventListener('touchend',(e)=>{ dragging=false; knob.style.transform='translate(0px,0px)'; move={f:0,b:0,l:0,r:0}; },{passive:false});
    interactBtn.addEventListener('click', ()=>{ const hit=centerRaycast(); if(hit) interactWith(hit.object); });
  }

  // interactions placeholder (no NPCs yet)
  function centerRaycast(){ if(!raycaster) return null; raycaster.setFromCamera(new THREE.Vector2(0,0), camera); const hits = raycaster.intersectObjects(npcs, true); return hits.length?hits[0]:null; }
  function interactWith(obj){ if(!obj) return; const lines = obj.userData.lines || LINES; const text = lines[Math.floor(Math.random()*lines.length)]; showQuote(text); if('speechSynthesis' in window){ const u=new SpeechSynthesisUtterance(text); u.rate=0.95; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); } saveFragment(text); }

  function showQuote(t){ quote.innerText = t; quote.style.display='block'; setTimeout(()=>quote.style.display='none',4000); }
  function saveFragment(t){ const arr = JSON.parse(localStorage.getItem('pp_fragments')||'[]'); arr.push({when:Date.now(),text:t}); localStorage.setItem('pp_fragments', JSON.stringify(arr)); updateHUD(); }
  function updateHUD(){ const arr = JSON.parse(localStorage.getItem('pp_fragments')||'[]'); hud.textContent = `Mode: Roam · Fragments: ${arr.length}`; }

  // cutscene: simple camera flyover into player position, then enable gameplay
  function startCutscene(){
    const from = new THREE.Vector3(0,60,160);
    const to = new THREE.Vector3(0,1.8,8);
    const lookAt = new THREE.Vector3(0,0,0);
    const duration = 8000; // 8 seconds
    const start = performance.now();
    camera.position.copy(from);
    camera.lookAt(0,0,0);
    let cutting = true;
    function tick(){
      const now = performance.now();
      let t = Math.min(1, (now - start)/duration);
      // ease in/out
      t = t<0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
      camera.position.lerpVectors(from, to, t);
      camera.lookAt(lookAt);
      if(cutting && now - start < duration){
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      } else {
        // enter gameplay: lock pointer on desktop
        cutting = false;
        // set player-facing camera
        camera.position.copy(to);
        camera.rotation.set(0,0,0);
        // allow pointer lock (user must click to lock — provide hint)
        // start main loop continues already in animate, we just enable controls if pointerlock desired
        // Remove overlay if any (already hidden)
      }
    }
    tick();
  }

  // animate loop
  function animate(){
    requestAnimationFrame(animate);
    if(!clock) clock = new THREE.Clock();
    const dt = clock.getDelta();
    const t = clock.getElapsedTime ? clock.getElapsedTime() : performance.now()*0.001;

    // traffic move
    for(const it of trafficArr){ it.line.position.z += it.speed * dt * 60; if(it.line.position.z > 40) it.line.position.z = -1200; }

    if(windowInst){ const o = 0.45 + Math.abs(Math.sin(t*2.2))*0.5; windowInst.material.opacity = o; windowInst.material.transparent = true; }

    // movement
    const speed = isMobile ? 2.6 : 4.6;
    const forward = (move.f?1:0) - (move.b?1:0);
    const lateral = (move.r?1:0) - (move.l?1:0);
    if(Math.abs(forward) + Math.abs(lateral) > 0){
      const dir = new THREE.Vector3(lateral,0,forward).normalize();
      const ang = player.rotation.y; const c=Math.cos(ang), s=Math.sin(ang);
      const dx = dir.x * c + dir.z * s; const dz = dir.z * c - dir.x * s;
      player.position.x += dx * speed * dt; player.position.z += dz * speed * dt;
      // footsteps
      try{ foot.currentTime=0; foot.play().catch(()=>{}); }catch(e){};
    }

    // simple ground constraint
    if(player.position.y < 0.5) player.position.y = 0.5;

    // camera follow
    camera.position.x += (player.position.x - camera.position.x) * 0.12;
    camera.position.z += (player.position.z + 8 - camera.position.z) * 0.12;
    camera.position.y += (1.7 - camera.position.y) * 0.12;
    camera.lookAt(player.position.x, player.position.y + 0.6, player.position.z);

    if(composer) composer.render();
    else renderer.render(scene, camera);

    updateHUD();
  }

  // resize
  function onResize(){ if(!renderer||!camera) return; camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); if(composer){ composer.setSize(window.innerWidth, window.innerHeight); const fxaa = composer.passes.find(p => p instanceof THREE.ShaderPass && p.material && p.material.uniforms && p.material.uniforms['resolution']); if(fxaa) fxaa.material.uniforms['resolution'].value.set(1/window.innerWidth,1/window.innerHeight); } }
  window.addEventListener('resize', onResize);

  // small arrays & helper
  const trafficArr = [];
  window.pp_neon = { fragments: ()=>JSON.parse(localStorage.getItem('pp_fragments')||'[]'), clear: ()=>{ localStorage.removeItem('pp_fragments'); updateHUD(); } };

  // end IIFE
})(); 
</script>
</body>
</html>
